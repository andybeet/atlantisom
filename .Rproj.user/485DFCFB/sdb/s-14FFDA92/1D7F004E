{
    "contents" : "#' Load Atlantis outputfiles (netcdf)\n#'\n#'\n#' This function loads Atlantis outputfiles (netcdf) and converts them to a dataframe.\n#' @param nc_out Connection of the ATLANTIS output file given as complete folder/filename string. Usually \"output[...].nc\".\n#' Additionally \"output[...]PROD.nc\" and \"output[...]CATCH.nc\" can be loaded.\n#' @param nc_init Connection of the ATLANTIS init file given as complete folder/filename string. Usually \"init[...].nc\".\n#' @param file_fgs Connection of the ATLANTIS functional groups file given as complete folder/filename string.\n#' Usually \"functionalGroups.csv\".\n#' @param select_groups Character vector of funtional groups which shall be plotted. Names have to match the ones\n#' used in the ncdf file. Check column \"Name\" in \"functionalGroups.csv\" for clarification.\n#' @param select_variable Character value spefifying which variables shall be loaded. Only one variable\n#' can be loaded at a time. Currently, only \"N\", \"Nums\", \"ResN\", \"StructN\", \"Eat\", \"Growth\", \"Prodn\",\n#' \"Grazing\" can be selected.\n#' @param remove_bboxes Logical specifying if an boundary boxes  shall be excluded. Default is T.\n#' @param check_acronyms Logical specifying if selected groups are active in the model run. This is used in automated runs.\n#' Since all groups are passed when plotting (plot_atlantis) is called via batch-file (which cannot be changed easily)\n#' this will result in errors if some groups are not active in the model run. By default this is TRUE.\n#' @family load functions\n#' @return Dataframe in long format with the following informations: Species, timestep, polygon, agecl and value (= \"atoutput\").\n\n#' @details This functions converts the ATLANTIS output to a dataframe which can be processed in R.\n#' @keywords gen\n#' @examples\n#' load_atlantis_output(model_path = file.path(\"z:\", \"Atlantis\", \"ATLANTIS NSmodel base\"), filename = \"outputNorthSea.nc\", select_groups = get_groups(), select_variable = \"ResN\", biomasspools = c(\"large_crabs\", \"small_epifauna\", \"sessile_epifauna\", \"epifaunal_macrobenthos\"))\n#' @export\n\nload_nc <- function(nc_out,\n                    nc_init,\n                    file_fgs,\n                    select_groups,\n                    select_variable,\n                    remove_bboxes,\n                    check_acronyms){\n  # NOTE: The extraction procedure may look a bit complex... A different approach would be to\n  # create a dataframe for each variable (e.g. GroupAge_Nums) and combine all dataframes\n  # at the end. However, this requires alot more storage and the code wouldn't be highly\n  # vectorised (which it is at the moment...)!\n\n  # Check input!\n  supported_variables <- c(\"N\", \"Nums\", \"ResN\", \"StructN\", \"Eat\", \"Growth\", \"Prodn\", \"Grazing\")\n  if (length(select_groups) == 0) stop(\"No Groups selected.\")\n  if (length(select_variable) == 0) stop(\"No Variables selected.\")\n  if (length(select_variable) > 1) stop(\"Only one variable allowed per function call.\")\n  if (any(!is.element(select_variable, supported_variables))) stop(paste(\"Only\", paste(supported_variables, collapse = \", \"), \"can be selected as 'select_variable'\"))\n\n  # Check input structure!\n  if (check_acronyms) {\n    active_groups <- read.table(file_fgs, sep = \",\", header = T)\n    active_groups <- as.vector(subset(active_groups, IsTurnedOn == 1)$Name)\n    inactive_groups <- select_groups[which(!is.element(select_groups, active_groups))]\n    if (length(inactive_groups) >= 1) {\n      select_groups <- select_groups[!is.element(select_groups, inactive_groups)]\n      warning(paste(paste(\"Some selected groups are not active in the model run. Check 'IsTurnedOn' in\", file_fgs, \"\\n\"),\n                    paste(inactive_groups, collapse = \"\\n\")))\n    }\n    if (all(!is.element(select_groups, active_groups))) {\n      stop(paste(\"None of the species selected are active in the model run. Check spelling and Check 'IsTurnedOn' in\", file_fgs, \"\\n\"))\n    }\n  }\n\n  # Load ATLANTIS output!\n  at_out <- RNetCDF::open.nc(con = nc_out)\n  on.exit(RNetCDF::close.nc(at_out))\n  # Character vector giving the names of biomasspools. Note this does not mean groups\n  # which are considered as biomasspools in ATLANTIS but species which are only present in the bottom layer.\n  biomasspools <- load_bps(file_fgs = file_fgs, nc_init = nc_init)\n  if (select_variable != \"N\" & all(is.element(select_groups, biomasspools))) stop(\"The only output for Biomasspools is N.\")\n\n  # Get info from netcdf file! (Filestructure and all variable names)\n  var_names_ncdf <- sapply(seq_len(RNetCDF::file.inq.nc(at_out)$nvars - 1),\n    function(x) RNetCDF::var.inq.nc(at_out, x)$name)\n  n_timesteps <- RNetCDF::dim.inq.nc(at_out, 0)$length\n  n_boxes     <- RNetCDF::dim.inq.nc(at_out, 1)$length\n  n_layers    <- RNetCDF::dim.inq.nc(at_out, 2)$length\n\n  # Extract data from the ncdf file! Create a vector of all potential variable names first! Only use names which\n  # are available in the ncdf-file as an extraction of missing variables is not possible! Unfortunately variable\n  # names for Prodn and Garzing use a \"\" instead of \"_\" as seperator... :)\n  # Create vecotr of available species at the end using search_clean! This is needed to create species-names\n  # lateron! This approach may seem complicate but it turns out that this approach is very robust since no\n  # user input is needed as the variable names are basically extracted from the available names in the ncdf file!\n  # WARNING: Only 10 cohorts are supported at the moment!\n  # In order to make the creation of variables as robust as possible we introduce differtent combinations\n  # of groups, variable and cohort! Only combinations present in the ncdf are used lateron! This makes the\n  # code both robust and fast!\n  # Loop over select_groups to use the same ordering! This is essential otherwise species names\n  # are not assigned correctly lateron!\n  cohorts <- 1:10\n  search <- list()\n  for (i in seq_along(select_groups)) {\n    search[[i]] <- c(unlist(lapply(paste0(select_groups[i], cohorts),                   paste0, select_variable)),           # GroupCohortVariable\n                     unlist(lapply(paste0(select_groups[i], select_variable),           paste0, cohorts)),                   # GroupVariableCohort\n                     unlist(lapply(paste0(select_groups[i], cohorts),                   paste, select_variable, sep = \"_\")), # GroupCohort_Variable\n                     unlist(lapply(paste(select_groups[i], select_variable, sep = \"_\"), paste0, cohorts)),                   # Group_VariableCohort\n                     unlist(lapply(paste(select_groups[i], cohorts, sep = \"_\"),         paste, select_variable, sep = \"_\")), # Group_Cohort_Variable\n                     unlist(lapply(paste(select_groups[i], select_variable, sep = \"_\"), paste, cohorts, sep = \"_\")),         # Group_Variable_Cohort\n                     unlist(paste0(select_groups[i], select_variable)),                                                      # GroupVariable\n                     unlist(paste(select_groups[i], select_variable, sep = \"_\")))                                            # Group_Variable\n    search[[i]] <- search[[i]][is.element(search[[i]], var_names_ncdf)]\n    search[[i]] <- unique(search[[i]])\n  }\n  search_clean <- do.call(c, search)\n\n  at_data <- lapply(search_clean, RNetCDF::var.get.nc, ncfile = at_out)\n\n  # Get final species and number of ageclasses per species\n  final_species <- select_groups[sapply(lapply(select_groups, grepl, x = search_clean), any)]\n  final_agecl <- read.table(file_fgs, sep = \",\", header = T)\n  final_agecl <- final_agecl$NumCohorts[sapply(final_species, function(x) which(x == final_agecl$Name))]\n\n  num_layers <- RNetCDF::var.get.nc(ncfile = at_out, variable = \"numlayers\")[,1]\n  # add sediment layer!\n  num_layers <- num_layers + ifelse(num_layers == 0, 0, 1)\n\n  # Create an array of layerids. Every entry in the array indicates if a layer is present (= 1)\n  # or not (= 0). Boxes without layers (= islands) have only 0s as id! This is used lateron to remove\n  # data from non-existent layers! By default output should be 0 in those layers. However, this approach is\n  # much more robust as true zeros are kept!!! In addition all layers in boundary boxes are also set\n  # to 0 if remove_bboxes is TRUE! This will speed up the code ALOT! In addition is helps to vectorise\n  # the dataframe creation. Applying a boolean array to an array results in a vector!\n  for (i in seq_along(num_layers)) {\n    if (i == 1) layerid <- array(dim = c(n_layers, n_boxes))\n    if (num_layers[i] == 0) {\n      layerid[, i] <- 0\n    } else {\n      if (remove_bboxes & is.element((i - 1), get_bboxes())) {\n        layerid[, i] <- 0\n      } else {\n        layerid[, i] <- c(rep(0, times = n_layers - num_layers[i]), rep(1, times = num_layers[i]))\n      }\n    }\n  }\n\n  # Create vectors for polygons and layers! Each vector has the length equal to one timestep!\n  # All data from islands and non-existent layers is removed! Therefore the length of these\n  # vectors is equal for each extracted variable!\n  boxes <- 0:(n_boxes - 1)\n  # Remove islands! and boundary boxes!\n  island_ids <- num_layers == 0\n  if (remove_bboxes) {\n    boundary_ids <- is.element(boxes, get_bboxes())\n    island_ids <- island_ids | boundary_ids\n  }\n  boxes <- boxes[!island_ids]\n  num_layers <- num_layers[!island_ids]\n\n  polygons <- rep(boxes, times = num_layers)\n  layers <- sapply(num_layers[num_layers != 0] - 2, function(x) c(seq(x, from = 0, by = 1), n_layers - 1))\n  if (any(sapply(layers, length) != num_layers[num_layers != 0])) {\n    stop(\"Number of layers incorrect. Contact package development team.\")\n  }\n  layers <- do.call(c, layers)\n  if (length(polygons) != length(layers)) stop(\"Number of polygons and layers do not match. Contact package development team.\")\n\n  # In the following section the data is transformed to a long dataframe! The code is written for speed!\n  # I haven't found any solution to vectorise the creation of the dataframe columns (species, age, polygons,...)\n  # when data from 2d and 3d arrays (e.g. select_variable = \"N\" all biomasspools are only present in the\n  # sediment layer.) are read in simultaneausly. Therefore the current \"messy\" solution splits tha data\n  # in 2 subpopulations: 2d-data and 3d-data!\n  at_data3d <- at_data[which(sapply(at_data, function(x) length(dim(x))) == 3)]\n  at_data2d <- at_data[which(sapply(at_data, function(x) length(dim(x))) == 2)]\n\n  int_fs <- final_species\n  int_fa <- final_agecl\n\n  if (length(at_data3d) >= 1) {\n    # Remove biomasspools if selected variable is \"N\"!\n    if (select_variable == \"N\") {\n      int_fs <- final_species[!is.element(final_species, biomasspools)]\n      int_fa <- final_agecl[!is.element(final_species, biomasspools)]\n      # Note this only works if age-structured vertebrates have 10 ageclasses!\n      int_fa[int_fa == 10] <- 1\n    }\n    for (i in seq_along(at_data3d)) {# for loop over all variables!\n      if (i == 1) result3d <- list()\n      for (j in 1:n_timesteps) {# loop over timesteps\n        if (j == 1) values <- array(dim = c(length(layers), n_timesteps))\n        values[, j] <- at_data3d[[i]][,, j][layerid == 1]\n      }\n      result3d[[i]] <- as.vector(values)\n    }\n    result3d <- data.frame(species = unlist(sapply(X = mapply(FUN = rep, x = int_fs, each = int_fa, SIMPLIFY = F, USE.NAMES = F),\n                                                   FUN = rep, each = length(layers) * n_timesteps, simplify = F)),\n                           agecl = unlist(sapply(X = sapply(X = int_fa, FUN = seq, from = 1, by = 1, simplify = F, USE.NAMES = F),\n                                                 FUN = rep, each = length(layers) * n_timesteps, simplify = F)),\n                           polygon = unlist(sapply(X = n_timesteps * int_fa, FUN = rep, x = polygons, simplify = F, USE.NAMES = F)),\n                           layer = unlist(sapply(X = n_timesteps * int_fa, FUN = rep, x = layers, simplify = F, USE.NAMES = F)),\n                           time = unlist(sapply(X = int_fa, FUN = rep, x = rep(0:(n_timesteps - 1), each = length(layers)), simplify = F, USE.NAMES = F)),\n                           atoutput = do.call(c, result3d),\n                           stringsAsFactors = F)\n  }\n\n  if (length(at_data2d) >= 1) {\n    # Only select biomasspools if selected variable is \"N\"!\n    if (select_variable == \"N\") {\n      int_fs <- final_species[is.element(final_species, biomasspools)]\n      int_fa <- final_agecl[is.element(final_species, biomasspools)]\n    }\n    if (select_variable == \"Grazing\") int_fa <- 1 # age-structured invert groups are combined in ncdf file!\n    for (i in seq_along(at_data2d)) {# for loop over all variables!\n      if (i == 1) result2d <- list()\n      for (j in 1:n_timesteps) {# loop over timesteps\n        if (j == 1) values <- array(dim = c(length(boxes), n_timesteps))\n        values[, j] <- at_data2d[[i]][, j][boxes + 1]\n      }\n      result2d[[i]] <- as.vector(values)\n    }\n\n    # Order of the data in value column = \"atoutput\".\n    # 1. species  --> rep each with the number of ageclasses and n_timesteps * boxes\n    # 2. age      --> rep each (1:10 for each species) with n_timesteps * boxes\n    # 3. timestep --> rep each timestep (1:n_timesteps) with the number of boxes and final_agecl\n    #                 (num cohorts per species)\n    # 4. polygon  --> rep boxes times n_timesteps * final_agecl (num cohorts per species)\n    # The code is highly vectorized and therefore quite effective!\n    result2d <- data.frame(species = unlist(sapply(X = mapply(FUN = rep, x = int_fs, each = int_fa, SIMPLIFY = F, USE.NAMES = F),\n                                                   FUN = rep, each = length(boxes) * n_timesteps, simplify = F)),\n                           agecl = unlist(sapply(X = sapply(X = int_fa, FUN = seq, from = 1, by = 1, simplify = F, USE.NAMES = F),\n                                                 FUN = rep, each = length(boxes) * n_timesteps, simplify = F)),\n                           polygon = unlist(sapply(X = n_timesteps * int_fa, FUN = rep, x = boxes, simplify = F, USE.NAMES = F)),\n                           time = unlist(sapply(X = int_fa, FUN = rep, x = rep(0:(n_timesteps - 1), each = length(boxes)), simplify = F, USE.NAMES = F)),\n                           atoutput = do.call(c, result2d),\n                           stringsAsFactors = F)\n    if (select_variable == \"N\") result2d$layer <- n_layers - 1\n  }\n\n  # Combine dataframes if necessary!\n  if (all(sapply(lapply(at_data, dim), length) == 3) & select_variable != \"N\") result <- result3d\n  if (all(sapply(lapply(at_data, dim), length) == 2) & select_variable != \"N\") result <- result2d\n  if (select_variable == \"N\") {\n    if (length(at_data2d) >= 1 & length(at_data3d) == 0) result <- result2d\n    if (length(at_data2d) == 0 & length(at_data3d) >= 1) result <- result3d\n    if (length(at_data2d) >= 1 & length(at_data3d) >= 1) result <- rbind(result2d, result3d)\n  }\n\n  # Remove min_pools if existent (well, there always are min pools... ;)).\n  min_pools <- is.element(result$atoutput, c(0, 1e-08, 1e-16))\n  if (length(min_pools) > 0) {\n    # exclude 1st timestep and sediment layer from calculation! They behave differently...\n    print_min_pools <- sum(min_pools) - length(result[min_pools & result$time == 1, 1]) - length(result[min_pools & result$time > 1 & result$layer == 7, 1])\n    if (print_min_pools > 0) warning(paste0(round(print_min_pools/dim(result)[1] * 100), \"% of \", select_variable, \" are true min-pools (0, 1e-08, 1e-16)\"))\n    result <- result[!min_pools, ]\n  }\n\n  # Remove non-existent layers.\n  # WARNING: Biomass is build up (very few) in sediment layer for NON sediment groups (e.g. baleen whales)\n  # Therefore, I subset all data from that layer for non biomass groups and groups which cannot penetrate into the sediment!\n  # UPDATE: Doesn't work with layers as species are not distributed through the whole water column and do not appear in\n  # every polygon. Therefore we subset zeros!\n#   if (all(is.element(c(\"layer\", \"polygon\"), names(result)))) {\n#     result <- dplyr::filter(result, !(layer == n_layers & !is.element(species, union(biomasspools, get_sediment_digger()))))\n#   }\n\n  # Sum up N for invert cohorts if invert cohorts are present!\n  # NOTE: invert cohorts of size 10 are not considered!\n  if (select_variable == \"N\" & any(final_agecl != 10 & final_agecl > 1)) {\n    result <- result %>%\n      dplyr::group_by(polygon, layer, species, time) %>%\n      dplyr::summarise(atoutput = sum(atoutput))\n  }\n\n  return(result)\n}\n\n\n",
    "created" : 1449508470293.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3211707424",
    "id" : "1D7F004E",
    "lastKnownWriteTime" : 1449509052,
    "path" : "C:/Users/alexk/Desktop/atlantisOM/R/load_nc.R",
    "project_path" : "R/load_nc.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}